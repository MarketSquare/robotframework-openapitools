<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="OpenApiLibCore" type="LIBRARY" format="HTML" scope="SUITE" generated="2025-05-11T17:22:53+00:00" specversion="6" source="/workspaces/robotframework-openapitools/src/OpenApiLibCore/openapi_libcore.py" lineno="174">
<version>1.0.0b3</version>
<doc>&lt;p&gt;Main class providing the keywords and core logic to interact with an OpenAPI server.&lt;/p&gt;
&lt;p&gt;Visit the &lt;a href="https://github.com/MarketSquare/robotframework-openapi-libcore"&gt;library page&lt;/a&gt; for an introduction.&lt;/p&gt;</doc>
<tags>
</tags>
<inits>
<init name="__init__" lineno="182">
<arguments repr="source: str, origin: str = , base_path: str = , response_validation: ValidationLevel = WARN, disable_server_validation: bool = True, mappings_path: str | Path = , invalid_property_default_response: int = 422, default_id_property_name: str = id, faker_locale: str | list[str] = , require_body_for_invalid_url: bool = False, recursion_limit: int = 1, recursion_default: JSON = {}, username: str = , password: str = , security_token: str = , auth: AuthBase | None = None, cert: str | tuple[str, str] = , verify_tls: bool | str = True, extra_headers: Mapping[str, str] = {}, cookies: MutableMapping[str, str] | RequestsCookieJar | None = None, proxies: MutableMapping[str, str] | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="source: str">
<name>source</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="origin: str = ">
<name>origin</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="base_path: str = ">
<name>base_path</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="response_validation: ValidationLevel = WARN">
<name>response_validation</name>
<type name="ValidationLevel" typedoc="ValidationLevel"/>
<default>WARN</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="disable_server_validation: bool = True">
<name>disable_server_validation</name>
<type name="bool" typedoc="boolean"/>
<default>True</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mappings_path: str | Path = ">
<name>mappings_path</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="Path" typedoc="Path"/>
</type>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="invalid_property_default_response: int = 422">
<name>invalid_property_default_response</name>
<type name="int" typedoc="integer"/>
<default>422</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="default_id_property_name: str = id">
<name>default_id_property_name</name>
<type name="str" typedoc="string"/>
<default>id</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="faker_locale: str | list[str] = ">
<name>faker_locale</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="list" typedoc="list">
<type name="str" typedoc="string"/>
</type>
</type>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="require_body_for_invalid_url: bool = False">
<name>require_body_for_invalid_url</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="recursion_limit: int = 1">
<name>recursion_limit</name>
<type name="int" typedoc="integer"/>
<default>1</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="recursion_default: JSON = {}">
<name>recursion_default</name>
<type name="JSON"/>
<default>{}</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="username: str = ">
<name>username</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="password: str = ">
<name>password</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="security_token: str = ">
<name>security_token</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="auth: AuthBase | None = None">
<name>auth</name>
<type name="Union" union="true">
<type name="AuthBase"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="cert: str | tuple[str, str] = ">
<name>cert</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="tuple" typedoc="tuple">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
</type>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="verify_tls: bool | str = True">
<name>verify_tls</name>
<type name="Union" union="true">
<type name="bool" typedoc="boolean"/>
<type name="str" typedoc="string"/>
</type>
<default>True</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="extra_headers: Mapping[str, str] = {}">
<name>extra_headers</name>
<type name="Mapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
<default>{}</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="cookies: MutableMapping[str, str] | RequestsCookieJar | None = None">
<name>cookies</name>
<type name="Union" union="true">
<type name="MutableMapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
<type name="RequestsCookieJar" typedoc="dictionary"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="proxies: MutableMapping[str, str] | None = None">
<name>proxies</name>
<type name="Union" union="true">
<type name="MutableMapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>&lt;h3&gt;Base parameters&lt;/h3&gt;
&lt;h4&gt;source&lt;/h4&gt;
&lt;p&gt;An absolute path to an openapi.json or openapi.yaml file or an url to such a file.&lt;/p&gt;
&lt;h4&gt;origin&lt;/h4&gt;
&lt;p&gt;The server (and port) of the target server. E.g. &lt;code&gt;https://localhost:8000&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;base_path&lt;/h4&gt;
&lt;p&gt;The routing between &lt;code&gt;origin&lt;/code&gt; and the paths as found in the &lt;code&gt;paths&lt;/code&gt; section in the openapi document. E.g. &lt;code&gt;/petshop/v2&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Test case execution&lt;/h3&gt;
&lt;h4&gt;response_validation&lt;/h4&gt;
&lt;p&gt;By default, a &lt;code&gt;WARN&lt;/code&gt; is logged when the Response received after a Request does not comply with the schema as defined in the openapi document for the given operation. The following values are supported:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DISABLED&lt;/code&gt;: All Response validation errors will be ignored&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INFO&lt;/code&gt;: Any Response validation erros will be logged at &lt;code&gt;INFO&lt;/code&gt; level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WARN&lt;/code&gt;: Any Response validation erros will be logged at &lt;code&gt;WARN&lt;/code&gt; level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STRICT&lt;/code&gt;: The Test Case will fail on any Response validation errors&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;disable_server_validation&lt;/h4&gt;
&lt;p&gt;If enabled by setting this parameter to &lt;code&gt;True&lt;/code&gt;, the Response validation will also include possible errors for Requests made to a server address that is not defined in the list of servers in the openapi document. This generally means that if there is a mismatch, every Test Case will raise this error. Note that &lt;code&gt;localhost&lt;/code&gt; and &lt;code&gt;127.0.0.1&lt;/code&gt; are not considered the same by Response validation.&lt;/p&gt;
&lt;h3&gt;API-specific configurations&lt;/h3&gt;
&lt;h4&gt;mappings_path&lt;/h4&gt;
&lt;p&gt;See &lt;a href="https://marketsquare.github.io/robotframework-openapi-libcore/advanced_use.html"&gt;this page&lt;/a&gt; for an in-depth explanation.&lt;/p&gt;
&lt;h4&gt;invalid_property_default_response&lt;/h4&gt;
&lt;p&gt;The default response code for requests with a JSON body that does not comply with the schema. Example: a value outside the specified range or a string value for a property defined as integer in the schema.&lt;/p&gt;
&lt;h4&gt;default_id_property_name&lt;/h4&gt;
&lt;p&gt;The default name for the property that identifies a resource (i.e. a unique entity) within the API. The default value for this property name is &lt;code&gt;id&lt;/code&gt;. If the target API uses a different name for all the resources within the API, you can configure it globally using this property.&lt;/p&gt;
&lt;p&gt;If different property names are used for the unique identifier for different types of resources, an &lt;code&gt;ID_MAPPING&lt;/code&gt; can be implemented using the &lt;code&gt;mappings_path&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;faker_locale&lt;/h4&gt;
&lt;p&gt;A locale string or list of locale strings to pass to the Faker library to be used in generation of string data for supported format types.&lt;/p&gt;
&lt;h4&gt;require_body_for_invalid_url&lt;/h4&gt;
&lt;p&gt;When a request is made against an invalid url, this usually is because of a "404" request; a request for a resource that does not exist. Depending on API implementation, when a request with a missing or invalid request body is made on a non-existent resource, either a 404 or a 422 or 400 Response is normally returned. If the API being tested processes the request body before checking if the requested resource exists, set this parameter to True.&lt;/p&gt;
&lt;h3&gt;Parsing parameters&lt;/h3&gt;
&lt;h4&gt;recursion_limit&lt;/h4&gt;
&lt;p&gt;The recursion depth to which to fully parse recursive references before the &lt;span class="name"&gt;recursion_default&lt;/span&gt; is used to end the recursion.&lt;/p&gt;
&lt;h4&gt;recursion_default&lt;/h4&gt;
&lt;p&gt;The value that is used instead of the referenced schema when the &lt;span class="name"&gt;recursion_limit&lt;/span&gt; has been reached. The default &lt;span class="name"&gt;{}&lt;/span&gt; represents an empty object in JSON. Depending on schema definitions, this may cause schema validation errors. If this is the case, 'None' (&lt;code&gt;${NONE}&lt;/code&gt; in Robot Framework) or an empty list can be tried as an alternative.&lt;/p&gt;
&lt;h3&gt;Security-related parameters&lt;/h3&gt;
&lt;p&gt;&lt;i&gt;Note: these parameters are equivalent to those in the &lt;code&gt;requests&lt;/code&gt; library.&lt;/i&gt;&lt;/p&gt;
&lt;h4&gt;username&lt;/h4&gt;
&lt;p&gt;The username to be used for Basic Authentication.&lt;/p&gt;
&lt;h4&gt;password&lt;/h4&gt;
&lt;p&gt;The password to be used for Basic Authentication.&lt;/p&gt;
&lt;h4&gt;security_token&lt;/h4&gt;
&lt;p&gt;The token to be used for token based security using the &lt;code&gt;Authorization&lt;/code&gt; header.&lt;/p&gt;
&lt;h4&gt;auth&lt;/h4&gt;
&lt;p&gt;A &lt;a href="https://requests.readthedocs.io/en/latest/api/#authentication"&gt;requests &lt;code&gt;AuthBase&lt;/code&gt; instance&lt;/a&gt; to be used for authentication instead of the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;cert&lt;/h4&gt;
&lt;p&gt;The SSL certificate to use with all requests. If string: the path to ssl client cert file (.pem). If tuple: the ('cert', 'key') pair.&lt;/p&gt;
&lt;h4&gt;verify_tls&lt;/h4&gt;
&lt;p&gt;Whether or not to verify the TLS / SSL certificate of the server. If boolean: whether or not to verify the server TLS certificate. If string: path to a CA bundle to use for verification.&lt;/p&gt;
&lt;h4&gt;extra_headers&lt;/h4&gt;
&lt;p&gt;A dictionary with extra / custom headers that will be send with every request. This parameter can be used to send headers that are not documented in the openapi document or to provide an API-key.&lt;/p&gt;
&lt;h4&gt;cookies&lt;/h4&gt;
&lt;p&gt;A dictionary or &lt;a href="https://docs.python.org/3/library/http.cookiejar.html#http.cookiejar.CookieJar"&gt;CookieJar object&lt;/a&gt; to send with all requests.&lt;/p&gt;
&lt;h4&gt;proxies&lt;/h4&gt;
&lt;p&gt;A dictionary of 'protocol': 'proxy url' to use for all requests.&lt;/p&gt;</doc>
<shortdoc>== Base parameters ==</shortdoc>
</init>
</inits>
<keywords>
<kw name="Assert Href To Resource Is Valid" lineno="722">
<arguments repr="href: str, referenced_resource: dict[str, JSON]">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="href: str">
<name>href</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="referenced_resource: dict[str, JSON]">
<name>referenced_resource</name>
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
</arg>
</arguments>
<doc>&lt;p&gt;Attempt to GET the resource referenced by the &lt;span class="name"&gt;href&lt;/span&gt; and validate it's equal to the provided &lt;span class="name"&gt;referenced_resource&lt;/span&gt; object / dictionary.&lt;/p&gt;</doc>
<shortdoc>Attempt to GET the resource referenced by the `href` and validate it's equal to the provided `referenced_resource` object / dictionary.</shortdoc>
</kw>
<kw name="Authorized Request" lineno="642">
<arguments repr="url: str, method: str, params: dict[str, Any] | None = None, headers: dict[str, str] | None = None, json_data: JSON | None = None, data: Any | None = None, files: Any | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="method: str">
<name>method</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="params: dict[str, Any] | None = None">
<name>params</name>
<type name="Union" union="true">
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="Any" typedoc="Any"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="headers: dict[str, str] | None = None">
<name>headers</name>
<type name="Union" union="true">
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="json_data: JSON | None = None">
<name>json_data</name>
<type name="Union" union="true">
<type name="JSON"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="data: Any | None = None">
<name>data</name>
<type name="Union" union="true">
<type name="Any" typedoc="Any"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="files: Any | None = None">
<name>files</name>
<type name="Union" union="true">
<type name="Any" typedoc="Any"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="Response"/>
<doc>&lt;p&gt;Perform a request using the security token or authentication set in the library.&lt;/p&gt;
&lt;p&gt;&lt;span class="name"&gt;json_data&lt;/span&gt;, &lt;span class="name"&gt;data&lt;/span&gt; and &lt;span class="name"&gt;files&lt;/span&gt; are passed to &lt;span class="name"&gt;requests.request&lt;/span&gt;s &lt;span class="name"&gt;json&lt;/span&gt;, &lt;span class="name"&gt;data&lt;/span&gt; and &lt;span class="name"&gt;files&lt;/span&gt; parameters unaltered. See the requests documentation for details: &lt;a href="https://requests.readthedocs.io/en/latest/api/#requests.request"&gt;https://requests.readthedocs.io/en/latest/api/#requests.request&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt; Note: provided username / password or auth objects take precedence over token based security&lt;/p&gt;</doc>
<shortdoc>Perform a request using the security token or authentication set in the library.</shortdoc>
</kw>
<kw name="Ensure In Use" lineno="627">
<arguments repr="url: str, resource_relation: IdReference">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="resource_relation: IdReference">
<name>resource_relation</name>
<type name="IdReference"/>
</arg>
</arguments>
<doc>&lt;p&gt;Ensure that the (right-most) &lt;span class="name"&gt;id&lt;/span&gt; of the resource referenced by the &lt;span class="name"&gt;url&lt;/span&gt; is used by the resource defined by the &lt;span class="name"&gt;resource_relation&lt;/span&gt;.&lt;/p&gt;</doc>
<shortdoc>Ensure that the (right-most) `id` of the resource referenced by the `url` is used by the resource defined by the `resource_relation`.</shortdoc>
</kw>
<kw name="Get Ids From Url" lineno="592">
<arguments repr="url: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<returntype name="list" typedoc="list">
<type name="str" typedoc="string"/>
</returntype>
<doc>&lt;p&gt;Perform a GET request on the &lt;span class="name"&gt;url&lt;/span&gt; and return the list of resource &lt;span class="name"&gt;ids&lt;/span&gt; from the response.&lt;/p&gt;</doc>
<shortdoc>Perform a GET request on the `url` and return the list of resource `ids` from the response.</shortdoc>
</kw>
<kw name="Get Invalid Body Data" lineno="489">
<arguments repr="url: str, method: str, status_code: int, request_data: RequestData">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="method: str">
<name>method</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="status_code: int">
<name>status_code</name>
<type name="int" typedoc="integer"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="request_data: RequestData">
<name>request_data</name>
<type name="RequestData"/>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</returntype>
<doc>&lt;p&gt;Return &lt;span class="name"&gt;json_data&lt;/span&gt; based on the &lt;span class="name"&gt;dto&lt;/span&gt; on the &lt;span class="name"&gt;request_data&lt;/span&gt; that will cause the provided &lt;span class="name"&gt;status_code&lt;/span&gt; for the &lt;span class="name"&gt;method&lt;/span&gt; operation on the &lt;span class="name"&gt;url&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&amp;gt; Note: applicable UniquePropertyValueConstraint and IdReference Relations are considered before changes to &lt;span class="name"&gt;json_data&lt;/span&gt; are made.&lt;/p&gt;</doc>
<shortdoc>Return `json_data` based on the `dto` on the `request_data` that will cause the provided `status_code` for the `method` operation on the `url`.</shortdoc>
</kw>
<kw name="Get Invalidated Parameters" lineno="512">
<arguments repr="status_code: int, request_data: RequestData">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="status_code: int">
<name>status_code</name>
<type name="int" typedoc="integer"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="request_data: RequestData">
<name>request_data</name>
<type name="RequestData"/>
</arg>
</arguments>
<returntype name="tuple" typedoc="tuple">
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
</returntype>
<doc>&lt;p&gt;Returns a version of &lt;span class="name"&gt;params, headers&lt;/span&gt; as present on &lt;span class="name"&gt;request_data&lt;/span&gt; that has been modified to cause the provided &lt;span class="name"&gt;status_code&lt;/span&gt;.&lt;/p&gt;</doc>
<shortdoc>Returns a version of `params, headers` as present on `request_data` that has been modified to cause the provided `status_code`.</shortdoc>
</kw>
<kw name="Get Invalidated Url" lineno="602">
<arguments repr="valid_url: str, path: str = , expected_status_code: int = 404">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="valid_url: str">
<name>valid_url</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="path: str = ">
<name>path</name>
<type name="str" typedoc="string"/>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="expected_status_code: int = 404">
<name>expected_status_code</name>
<type name="int" typedoc="integer"/>
<default>404</default>
</arg>
</arguments>
<returntype name="str" typedoc="string"/>
<doc>&lt;p&gt;Return an url with all the path parameters in the &lt;span class="name"&gt;valid_url&lt;/span&gt; replaced by a random UUID if no PathPropertiesConstraint is mapped for the &lt;span class="name"&gt;"get"&lt;/span&gt; operation on the mapped &lt;a href="#type-Path" class="name"&gt;path&lt;/a&gt; and &lt;span class="name"&gt;expected_status_code&lt;/span&gt;. If a PathPropertiesConstraint is mapped, the &lt;span class="name"&gt;invalid_value&lt;/span&gt; is returned.&lt;/p&gt;
&lt;p&gt;Raises ValueError if the valid_url cannot be invalidated.&lt;/p&gt;</doc>
<shortdoc>Return an url with all the path parameters in the `valid_url` replaced by a random UUID if no PathPropertiesConstraint is mapped for the `"get"` operation on the mapped `path` and `expected_status_code`. If a PathPropertiesConstraint is mapped, the `invalid_value` is returned.</shortdoc>
</kw>
<kw name="Get Json Data With Conflict" lineno="528">
<arguments repr="url: str, method: str, dto: Dto, conflict_status_code: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="method: str">
<name>method</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="dto: Dto">
<name>dto</name>
<type name="Dto"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="conflict_status_code: int">
<name>conflict_status_code</name>
<type name="int" typedoc="integer"/>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</returntype>
<doc>&lt;p&gt;Return &lt;span class="name"&gt;json_data&lt;/span&gt; based on the &lt;span class="name"&gt;UniquePropertyValueConstraint&lt;/span&gt; that must be returned by the &lt;span class="name"&gt;get_relations&lt;/span&gt; implementation on the &lt;span class="name"&gt;dto&lt;/span&gt; for the given &lt;span class="name"&gt;conflict_status_code&lt;/span&gt;.&lt;/p&gt;</doc>
<shortdoc>Return `json_data` based on the `UniquePropertyValueConstraint` that must be returned by the `get_relations` implementation on the `dto` for the given `conflict_status_code`.</shortdoc>
</kw>
<kw name="Get Parameterized Path From Url" lineno="578">
<arguments repr="url: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<returntype name="str" typedoc="string"/>
<doc>&lt;p&gt;Return the path as found in the &lt;span class="name"&gt;paths&lt;/span&gt; section based on the given &lt;span class="name"&gt;url&lt;/span&gt;.&lt;/p&gt;</doc>
<shortdoc>Return the path as found in the `paths` section based on the given `url`.</shortdoc>
</kw>
<kw name="Get Request Data" lineno="478">
<arguments repr="path: str, method: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="method: str">
<name>method</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<returntype name="RequestData"/>
<doc>&lt;p&gt;Return an object with valid request data for body, headers and query params.&lt;/p&gt;</doc>
<shortdoc>Return an object with valid request data for body, headers and query params.</shortdoc>
</kw>
<kw name="Get Request Values" lineno="437">
<arguments repr="path: str, method: str, overrides: Mapping[str, JSON] = {}">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="method: str">
<name>method</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="overrides: Mapping[str, JSON] = {}">
<name>overrides</name>
<type name="Mapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
<default>{}</default>
</arg>
</arguments>
<returntype name="RequestValues"/>
<doc>&lt;p&gt;Return an object with all (valid) request values needed to make a request.&lt;/p&gt;</doc>
<shortdoc>Return an object with all (valid) request values needed to make a request.</shortdoc>
</kw>
<kw name="Get Valid Id For Path" lineno="566">
<arguments repr="path: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<returntype name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="int" typedoc="integer"/>
<type name="float" typedoc="float"/>
</returntype>
<doc>&lt;p&gt;Support keyword that returns the &lt;span class="name"&gt;id&lt;/span&gt; for an existing resource at &lt;a href="#type-Path" class="name"&gt;path&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To prevent resource conflicts with other test cases, a new resource is created (by a POST operation) if possible.&lt;/p&gt;</doc>
<shortdoc>Support keyword that returns the `id` for an existing resource at `path`.</shortdoc>
</kw>
<kw name="Get Valid Url" lineno="547">
<arguments repr="path: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<returntype name="str" typedoc="string"/>
<doc>&lt;p&gt;This keyword returns a valid url for the given &lt;a href="#type-Path" class="name"&gt;path&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If the &lt;a href="#type-Path" class="name"&gt;path&lt;/a&gt; contains path parameters the Get Valid Id For Path keyword will be executed to retrieve valid ids for the path parameters.&lt;/p&gt;
&lt;p&gt;&amp;gt; Note: if valid ids cannot be retrieved within the scope of the API, the &lt;span class="name"&gt;PathPropertiesConstraint&lt;/span&gt; Relation can be used. More information can be found &lt;a href="https://marketsquare.github.io/robotframework-openapitools/advanced_use.html"&gt;here&lt;/a&gt;.&lt;/p&gt;</doc>
<shortdoc>This keyword returns a valid url for the given `path`.</shortdoc>
</kw>
<kw name="Perform Validated Request" lineno="691">
<arguments repr="path: str, status_code: int, request_values: RequestValues, original_data: Mapping[str, JSON] = {}">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="status_code: int">
<name>status_code</name>
<type name="int" typedoc="integer"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="request_values: RequestValues">
<name>request_values</name>
<type name="RequestValues"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="original_data: Mapping[str, JSON] = {}">
<name>original_data</name>
<type name="Mapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
<default>{}</default>
</arg>
</arguments>
<doc>&lt;p&gt;This keyword first calls the Authorized Request keyword, then the Validate Response keyword and finally validates, for &lt;span class="name"&gt;DELETE&lt;/span&gt; operations, whether the target resource was indeed deleted (OK response) or not (error responses).&lt;/p&gt;</doc>
<shortdoc>This keyword first calls the Authorized Request keyword, then the Validate Response keyword and finally validates, for `DELETE` operations, whether the target resource was indeed deleted (OK response) or not (error responses).</shortdoc>
</kw>
<kw name="Set Auth" lineno="415">
<arguments repr="auth: AuthBase">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="auth: AuthBase">
<name>auth</name>
<type name="AuthBase"/>
</arg>
</arguments>
<doc>&lt;p&gt;Set the &lt;span class="name"&gt;auth&lt;/span&gt; used for authentication after the library is imported.&lt;/p&gt;
&lt;p&gt;After calling this keyword, subsequent requests will use the provided &lt;span class="name"&gt;auth&lt;/span&gt; instance.&lt;/p&gt;</doc>
<shortdoc>Set the `auth` used for authentication after the library is imported.</shortdoc>
</kw>
<kw name="Set Basic Auth" lineno="403">
<arguments repr="username: str, password: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="username: str">
<name>username</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="password: str">
<name>password</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<doc>&lt;p&gt;Set the &lt;span class="name"&gt;username&lt;/span&gt; and &lt;span class="name"&gt;password&lt;/span&gt; used for basic authentication after the library is imported.&lt;/p&gt;
&lt;p&gt;After calling this keyword, subsequent requests will use the provided credentials.&lt;/p&gt;</doc>
<shortdoc>Set the `username` and `password` used for basic authentication after the library is imported.</shortdoc>
</kw>
<kw name="Set Extra Headers" lineno="425">
<arguments repr="extra_headers: dict[str, str]">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="extra_headers: dict[str, str]">
<name>extra_headers</name>
<type name="dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
</arg>
</arguments>
<doc>&lt;p&gt;Set the &lt;span class="name"&gt;extra_headers&lt;/span&gt; used in requests after the library is imported.&lt;/p&gt;
&lt;p&gt;After calling this keyword, subsequent requests will use the provided &lt;span class="name"&gt;extra_headers&lt;/span&gt;.&lt;/p&gt;</doc>
<shortdoc>Set the `extra_headers` used in requests after the library is imported.</shortdoc>
</kw>
<kw name="Set Origin" lineno="380">
<arguments repr="origin: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="origin: str">
<name>origin</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<doc>&lt;p&gt;Set the &lt;span class="name"&gt;origin&lt;/span&gt; after the library is imported.&lt;/p&gt;
&lt;p&gt;This can be done during the &lt;span class="name"&gt;Suite setup&lt;/span&gt; when using DataDriver in situations where the OpenAPI document is available on disk but the target host address is not known before the test starts.&lt;/p&gt;
&lt;p&gt;In combination with OpenApiLibCore, the &lt;span class="name"&gt;origin&lt;/span&gt; can be used at any point to target another server that hosts an API that complies to the same OAS.&lt;/p&gt;</doc>
<shortdoc>Set the `origin` after the library is imported.</shortdoc>
</kw>
<kw name="Set Security Token" lineno="394">
<arguments repr="security_token: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="security_token: str">
<name>security_token</name>
<type name="str" typedoc="string"/>
</arg>
</arguments>
<doc>&lt;p&gt;Set the &lt;span class="name"&gt;security_token&lt;/span&gt; after the library is imported.&lt;/p&gt;
&lt;p&gt;After calling this keyword, subsequent requests will use the provided token.&lt;/p&gt;</doc>
<shortdoc>Set the `security_token` after the library is imported.</shortdoc>
</kw>
<kw name="Validate Response" lineno="737">
<arguments repr="path: str, response: Response, original_data: Mapping[str, JSON] = {}">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="response: Response">
<name>response</name>
<type name="Response"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="original_data: Mapping[str, JSON] = {}">
<name>original_data</name>
<type name="Mapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
<default>{}</default>
</arg>
</arguments>
<doc>&lt;p&gt;Validate the &lt;span class="name"&gt;response&lt;/span&gt; by performing the following validations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;validate the &lt;span class="name"&gt;response&lt;/span&gt; against the openapi schema for the &lt;a href="#type-Path" class="name"&gt;path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;validate that the response does not contain extra properties&lt;/li&gt;
&lt;li&gt;validate that a href, if present, refers to the correct resource&lt;/li&gt;
&lt;li&gt;validate that the value for a property that is in the response is equal to the property value that was send&lt;/li&gt;
&lt;li&gt;validate that no &lt;span class="name"&gt;original_data&lt;/span&gt; is preserved when performing a PUT operation&lt;/li&gt;
&lt;li&gt;validate that a PATCH operation only updates the provided properties&lt;/li&gt;
&lt;/ul&gt;</doc>
<shortdoc>Validate the `response` by performing the following validations: - validate the `response` against the openapi schema for the `path` - validate that the response does not contain extra properties - validate that a href, if present, refers to the correct resource - validate that the value for a property that is in the response is equal to     the property value that was send - validate that no `original_data` is preserved when performing a PUT operation - validate that a PATCH operation only updates the provided properties</shortdoc>
</kw>
<kw name="Validate Response Using Validator" lineno="711">
<arguments repr="response: Response">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="response: Response">
<name>response</name>
<type name="Response"/>
</arg>
</arguments>
<doc>&lt;p&gt;Validate the &lt;span class="name"&gt;response&lt;/span&gt; against the OpenAPI Spec that is loaded during library initialization.&lt;/p&gt;</doc>
<shortdoc>Validate the `response` against the OpenAPI Spec that is loaded during library initialization.</shortdoc>
</kw>
<kw name="Validate Send Response" lineno="767">
<arguments repr="response: Response, original_data: Mapping[str, JSON] = {}">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="response: Response">
<name>response</name>
<type name="Response"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="original_data: Mapping[str, JSON] = {}">
<name>original_data</name>
<type name="Mapping" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="JSON"/>
</type>
<default>{}</default>
</arg>
</arguments>
<doc>&lt;p&gt;Validate that each property that was send that is in the response has the value that was send. In case a PATCH request, validate that only the properties that were patched have changed and that other properties are still at their pre-patch values.&lt;/p&gt;</doc>
<shortdoc>Validate that each property that was send that is in the response has the value that was send. In case a PATCH request, validate that only the properties that were patched have changed and that other properties are still at their pre-patch values.</shortdoc>
</kw>
</keywords>
<typedocs>
<type name="Any" type="Standard">
<doc>&lt;p&gt;Any value is accepted. No conversion is done.&lt;/p&gt;</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>Authorized Request</usage>
</usages>
</type>
<type name="boolean" type="Standard">
<doc>&lt;p&gt;Strings &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;YES&lt;/code&gt;, &lt;code&gt;ON&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are converted to Boolean &lt;code&gt;True&lt;/code&gt;, the empty string as well as strings &lt;code&gt;FALSE&lt;/code&gt;, &lt;code&gt;NO&lt;/code&gt;, &lt;code&gt;OFF&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; are converted to Boolean &lt;code&gt;False&lt;/code&gt;, and the string &lt;code&gt;NONE&lt;/code&gt; is converted to the Python &lt;code&gt;None&lt;/code&gt; object. Other strings and other accepted values are passed as-is, allowing keywords to handle them specially if needed. All string comparisons are case-insensitive.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;TRUE&lt;/code&gt; (converted to &lt;code&gt;True&lt;/code&gt;), &lt;code&gt;off&lt;/code&gt; (converted to &lt;code&gt;False&lt;/code&gt;), &lt;code&gt;example&lt;/code&gt; (used as-is)&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>__init__</usage>
</usages>
</type>
<type name="dictionary" type="Standard">
<doc>&lt;p&gt;Strings must be Python &lt;a href="https://docs.python.org/library/stdtypes.html#dict"&gt;dictionary&lt;/a&gt; literals. They are converted to actual dictionaries using the &lt;a href="https://docs.python.org/library/ast.html#ast.literal_eval"&gt;ast.literal_eval&lt;/a&gt; function. They can contain any values &lt;code&gt;ast.literal_eval&lt;/code&gt; supports, including dictionaries and other containers.&lt;/p&gt;
&lt;p&gt;If the type has nested types like &lt;code&gt;dict[str, int]&lt;/code&gt;, items are converted to those types automatically. This in new in Robot Framework 6.0.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;{'a': 1, 'b': 2}&lt;/code&gt;, &lt;code&gt;{'key': 1, 'nested': {'key': 2}}&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>Mapping</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Assert Href To Resource Is Valid</usage>
<usage>Authorized Request</usage>
<usage>Get Invalid Body Data</usage>
<usage>Get Invalidated Parameters</usage>
<usage>Get Json Data With Conflict</usage>
<usage>Get Request Values</usage>
<usage>Perform Validated Request</usage>
<usage>Set Extra Headers</usage>
<usage>Validate Response</usage>
<usage>Validate Send Response</usage>
</usages>
</type>
<type name="float" type="Standard">
<doc>&lt;p&gt;Conversion is done using Python's &lt;a href="https://docs.python.org/library/functions.html#float"&gt;float&lt;/a&gt; built-in function.&lt;/p&gt;
&lt;p&gt;Starting from RF 4.1, spaces and underscores can be used as visual separators for digit grouping purposes.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;3.14&lt;/code&gt;, &lt;code&gt;2.9979e8&lt;/code&gt;, &lt;code&gt;10 000.000 01&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>Real</type>
</accepts>
<usages>
<usage>Get Valid Id For Path</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>&lt;p&gt;Conversion is done using Python's &lt;a href="https://docs.python.org/library/functions.html#int"&gt;int&lt;/a&gt; built-in function. Floating point numbers are accepted only if they can be represented as integers exactly. For example, &lt;code&gt;1.0&lt;/code&gt; is accepted and &lt;code&gt;1.1&lt;/code&gt; is not.&lt;/p&gt;
&lt;p&gt;Starting from RF 4.1, it is possible to use hexadecimal, octal and binary numbers by prefixing values with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; and &lt;code&gt;0b&lt;/code&gt;, respectively.&lt;/p&gt;
&lt;p&gt;Starting from RF 4.1, spaces and underscores can be used as visual separators for digit grouping purposes.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0b1010&lt;/code&gt;, &lt;code&gt;10 000 000&lt;/code&gt;, &lt;code&gt;0xBAD_C0FFEE&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Get Invalid Body Data</usage>
<usage>Get Invalidated Parameters</usage>
<usage>Get Invalidated Url</usage>
<usage>Get Json Data With Conflict</usage>
<usage>Get Valid Id For Path</usage>
<usage>Perform Validated Request</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>&lt;p&gt;Strings must be Python &lt;a href="https://docs.python.org/library/stdtypes.html#list"&gt;list&lt;/a&gt; literals. They are converted to actual lists using the &lt;a href="https://docs.python.org/library/ast.html#ast.literal_eval"&gt;ast.literal_eval&lt;/a&gt; function. They can contain any values &lt;code&gt;ast.literal_eval&lt;/code&gt; supports, including lists and other containers.&lt;/p&gt;
&lt;p&gt;If the type has nested types like &lt;code&gt;list[int]&lt;/code&gt;, items are converted to those types automatically. This in new in Robot Framework 6.0.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;['one', 'two']&lt;/code&gt;, &lt;code&gt;[('one', 1), ('two', 2)]&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Get Ids From Url</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>&lt;p&gt;String &lt;code&gt;NONE&lt;/code&gt; (case-insensitive) is converted to Python &lt;code&gt;None&lt;/code&gt; object. Other values cause an error.&lt;/p&gt;</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Authorized Request</usage>
</usages>
</type>
<type name="Path" type="Standard">
<doc>&lt;p&gt;Strings are converted &lt;a href="https://docs.python.org/library/pathlib.html"&gt;Path&lt;/a&gt; objects. On Windows &lt;code&gt;/&lt;/code&gt; is converted to &lt;code&gt;\&lt;/code&gt; automatically.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;/tmp/absolute/path&lt;/code&gt;, &lt;code&gt;relative/path/to/file.ext&lt;/code&gt;, &lt;code&gt;name.txt&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>PurePath</type>
</accepts>
<usages>
<usage>__init__</usage>
</usages>
</type>
<type name="string" type="Standard">
<doc>&lt;p&gt;All arguments are converted to Unicode strings.&lt;/p&gt;</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Assert Href To Resource Is Valid</usage>
<usage>Authorized Request</usage>
<usage>Ensure In Use</usage>
<usage>Get Ids From Url</usage>
<usage>Get Invalid Body Data</usage>
<usage>Get Invalidated Parameters</usage>
<usage>Get Invalidated Url</usage>
<usage>Get Json Data With Conflict</usage>
<usage>Get Parameterized Path From Url</usage>
<usage>Get Request Data</usage>
<usage>Get Request Values</usage>
<usage>Get Valid Id For Path</usage>
<usage>Get Valid Url</usage>
<usage>Perform Validated Request</usage>
<usage>Set Basic Auth</usage>
<usage>Set Extra Headers</usage>
<usage>Set Origin</usage>
<usage>Set Security Token</usage>
<usage>Validate Response</usage>
<usage>Validate Send Response</usage>
</usages>
</type>
<type name="tuple" type="Standard">
<doc>&lt;p&gt;Strings must be Python &lt;a href="https://docs.python.org/library/stdtypes.html#tuple"&gt;tuple&lt;/a&gt; literals. They are converted to actual tuples using the &lt;a href="https://docs.python.org/library/ast.html#ast.literal_eval"&gt;ast.literal_eval&lt;/a&gt; function. They can contain any values &lt;code&gt;ast.literal_eval&lt;/code&gt; supports, including tuples and other containers.&lt;/p&gt;
&lt;p&gt;If the type has nested types like &lt;code&gt;tuple[str, int, int]&lt;/code&gt;, items are converted to those types automatically. This in new in Robot Framework 6.0.&lt;/p&gt;
&lt;p&gt;Examples: &lt;code&gt;('one', 'two')&lt;/code&gt;, &lt;code&gt;(('one', 1), ('two', 2))&lt;/code&gt;&lt;/p&gt;</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Get Invalidated Parameters</usage>
</usages>
</type>
<type name="ValidationLevel" type="Enum">
<doc>&lt;p&gt;The available levels for the response_validation parameter.&lt;/p&gt;</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>__init__</usage>
</usages>
<members>
<member name="DISABLED" value="DISABLED"/>
<member name="INFO" value="INFO"/>
<member name="WARN" value="WARN"/>
<member name="STRICT" value="STRICT"/>
</members>
</type>
</typedocs>
</keywordspec>
